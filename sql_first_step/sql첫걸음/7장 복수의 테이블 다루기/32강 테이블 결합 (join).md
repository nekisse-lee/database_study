## 테이블 결합 (join)

1.  곱집합과 교차집합
곱집합은 합집합이나 교집합처럼 집합의 연산 방법 중 하나다.

- 교차결합(cross join)
  - select 명령에서 from구에 테이블을 두 개 지정하면 이들은 곱집합으로 계산된다.
  
  ```
  - 교차결합
  select * from 테이블명1, 테이블명2
  ```
  
- ex) sample72_x와 sample72_y
  - select * from sample72_x;
    
    | x    |
    |------|
    | A    |
    | B    |
    | C    |
    
  - select * from sample72_y;
    
    | y    |
    |------|
    |    1 |
    |    2 |
    |    3 |
    
  - select * from sample72_x, sample72_y;
     - 같은 결과
     - select * from sample72_x cross join sample72_y;
      
    | x    | y    |
    |------|------|
    | A    |    1 |
    | B    |    1 |
    | C    |    1 |
    | A    |    2 |
    | B    |    2 |
    | C    |    2 |
    | A    |    3 |
    | B    |    3 |
    | C    |    3 |
    
    
### 2. 내부결합 

- 상품 테이블 작성
  ```sql
    create table 상품(
      상품코드 char(4) not null,
      상품명 varchar(30),
      메이커명 varchar(30),
      가격 integer,
      상품분류 varchar(30),
      primary key (상품코드)
  );
  ```
  
- 재고수 테이블 작성
  ```sql
  create table 재고수(
    상품코드 char(4),
    입고날짜 date,
    재고수 integer
    );
  ```
  
- ex) 상품 테이블과 재고수 테이블을 교차결합하기
  - select * from 상품, 재고수;
    
    | 상품코드     | 상품명    | 메이커명     | 가격   | 상품분류     | 상품코드     | 입고날짜     | 재고수    |
    |--------------|-----------|--------------|--------|--------------|--------------|--------------|-----------|
    | 0001         | 상품1     | 메이커1      |    100 | 식료품       | 0001         | 2014-01-03   |       200 |
    | 0002         | 상품2     | 메이커2      |    200 | 식료품       | 0001         | 2014-01-03   |       200 |
    | 0003         | 상품3     | 메이커3      |   1980 | 생활용품     | 0001         | 2014-01-03   |       200 |
    | 0001         | 상품1     | 메이커1      |    100 | 식료품       | 0002         | 2014-02-10   |       500 |
    | 0002         | 상품2     | 메이커2      |    200 | 식료품       | 0002         | 2014-02-10   |       500 |
    | 0003         | 상품3     | 메이커3      |   1980 | 생활용품     | 0002         | 2014-02-10   |       500 |
    | 0001         | 상품1     | 메이커1      |    100 | 식료품       | 0003         | 2014-02-14   |        10 |
    | 0002         | 상품2     | 메이커2      |    200 | 식료품       | 0003         | 2014-02-14   |        10 |
    | 0003         | 상품3     | 메이커3      |   1980 | 생활용품     | 0003         | 2014-02-14   |        10 |
    
  - 상품코드가 같은 행을 검색하기
    - select * from 상품, 재고수 where 상품.상품코드 = 재고수.상품코드;
      
      | 상품코드     | 상품명    | 메이커명     | 가격   | 상품분류     | 상품코드     | 입고날짜     | 재고수    |
      |--------------|-----------|--------------|--------|--------------|--------------|--------------|-----------|
      | 0001         | 상품1     | 메이커1      |    100 | 식료품       | 0001         | 2014-01-03   |       200 |
      | 0002         | 상품2     | 메이커2      |    200 | 식료품       | 0002         | 2014-02-10   |       500 |
      | 0003         | 상품3     | 메이커3      |   1980 | 생활용품     | 0003         | 2014-02-14   |        10 |
    
  - 상품코드가 같은 행을 검색 + 상품분류가 '식료품' 인 행과 열 의  상품명과, 재고수 출력
    ```sql
    select 상품.상품명, 재고수.재고수 
    from 상품, 재고수 
    where 상품.상품코드 = 재고수.상품코드 
    and 상품.상품분류 = '식료품';
    ```
    
    | 상품명    | 재고수    |
    |-----------|-----------|
    | 상품1     |       200 |
    | 상품2     |       500 |
    
    - where 구에는 `두 개의 조건식`이 지정되어 있다.  
    첫 번째 조건식은 교차결합으로 계산된 곱집합에서 원하는 `조합을 검색`하는 것  
    두 번째 조건식은 `결합 조건이 아닌 검색 조건`
    여기서 첫 번째 조건식의 조건은 `결합조건`
    
### 3. inner join으로 내부결합하기

- from 구에 테이블을 복수 지정해 가로 방향으로 테이블을 결합할 수 있다.
- 교차결합을 하면 곱집합으로 계산된다.
- where 조건을 지정해 곱집합에서 필요한 조합만 검색할 수 있다.

#### 위의 설명한 결합방법은 구식이다.
최근에는 inner join 키워드를 사용한 결합방법이 일반적으로 통용된다.  

 위의 2.  의 예제들을 inner join으로 변경
 ```sql 
-- 구식 결합
select 상품.상품명, 재고수.재고수 
from 상품, 재고수 
where 상품.상품코드 = 재고수.상품코드 
  and 상품.상품분류 = '식료품';
```

```sql 
-- inner join
select 상품.상품명, 재고수.재고수 
from 상품 
    inner join 재고수 
        on 상품.상품코드 = 재고수.상품코드 
where 상품.상품분류 = '식료품';
```

```sql
-- 내부결합 (inner join)
select * from 테이블명1 
    inner join 테이블명2 
        on 결합조건;
```

구식 방법에서는 쉼표(,)로 구분하여 테이블을 from 구에 지정.  
새로운 형식에서는 테이블과 테이블 사이에 'inner join' 이라는 키워드를 삽입.  

구식 방법에서는 `where 구에 결합조건`(where 상품.상품코드 = 재고수.상품코드)을 지정하였지만,  
inner join에서는 `on 을 사용하여 결합조건`(on 상품.상품코드 = 재고수.상품코드)을 지정
    
    
### 4. 내부결합을 활용한 데이터 관리.

```sql
-- 메이커 테이블 작성쿼리
CREATE TABLE `메이커` (
  `메이커코드` char(4) NOT NULL,
  `메이커명` varchar(30) DEFAULT NULL,
  PRIMARY KEY (`메이커코드`)
);
INSERT INTO `메이커` VALUES ('M001','메이커1'),('M002','메이커2');
```

```sql
-- 상품2 테이블 작성쿼리
CREATE TABLE `상품2` (
  `상품코드` char(4) NOT NULL,
  `상품명` varchar(30) DEFAULT NULL,
  `메이커코드` char(4) DEFAULT NULL,
  `가격` int(11) DEFAULT NULL,
  `상품분류` varchar(30) DEFAULT NULL,
  PRIMARY KEY (`상품코드`)
);
INSERT INTO `상품2` VALUES ('0001','상품1','M001',100,'식료품'),('0002','상품2','M001',200,'식료품'),('0003','상품3','M002',1980,'생활용품');
```
- ex) 상품 테이블과 메이커 테이블을 내부결합하기
  - select * from 상품2;
     
    | 상품코드     | 상품명    | 메이커코드      | 가격   | 상품분류     |
    |--------------|-----------|-----------------|--------|--------------|
    | 0001         | 상품1     | M001            |    100 | 식료품       |
    | 0002         | 상품2     | M001            |    200 | 식료품       |
    | 0003         | 상품3     | M002            |   1980 | 생활용품     |
  - select * from 메이커;  
    
    | 메이커코드      | 메이커명     |
    |-----------------|--------------|
    | M001            | 메이커1      |
    | M002            | 메이커2      |
  
  - ex) select s.상품명, m.메이커명 from 상품2 s inner join 메이커 m on s.메이커코드=m.메이커코드;
     
    |상품명    | 메이커명     |
    |-----------|--------------|
    | 상품1     | 메이커1      |
    | 상품2     | 메이커1      |
    | 상품3     | 메이커2      |
    
상품테이블에 메이커 모드만을 살펴보면 중복하는 행이 있다.  
상품xx 와 상품oo는 같은 yy메이커가 제조한 상품인 경우에 해당한다.  
기본키 제약은 상품코드에만 적용되어 있어 데이터상으로도 제약에 위반되지 않는다.  
반대로 메이커 테이블은 메이커코드에 기본키(Primary key\[PK])가 지정되어 있기 떄문에 중복을 허용치 않는다.  
`이 부분이 결합이나 데이터베이스의 테이블 설계를 이해하는 동시에 핵심이 되는 개념`  
A 테이블과 B 테이블 결합시,   
A와 B 중 어느 쪽이 하나의 행만 가지는지(일대다, 다대일) 아니면 양쪽 모두 하나의 행을 가지는지(일대일)  
 등과 같은 `'서로 결합하는 테이블 간의 관계'` 가 중요하다.
  
#### - 외부키
메이커 테이블의 메이커코드는 기본키이다.  
그에 비해 상품 테이블의 메이커코드는 '외부키'라 불리는 것으로,  
다른 테이블의 기본키를  참조하는 열이 외부키가 된다.

### 5. 외부결합  (left join, right join)
외부결합도 교차결합으로 결합 조건을 지정하여 검색한다는 기본적인 방식은 같다.  
'어느 한 쪽에만 존재하는 데이터행을 어떻게 다룰지'를 변경할 수 있는 결합방법이다.  
상품 테이블과 재고수 테이블 중에 상품 테이블에만 행이 존재하는 상황을 생각해보자.  

```sql
 -- 상품3 테이블 생성 코드
CREATE TABLE `상품3` (
  `상품코드` char(4) NOT NULL,
  `상품명` varchar(30) DEFAULT NULL,
  `메이커코드` char(4) DEFAULT NULL,
  `가격` int(11) DEFAULT NULL,
  `상품분류` varchar(30) DEFAULT NULL,
  PRIMARY KEY (`상품코드`)
);
INSERT INTO `상품3` VALUES ('0001','상품1','M001',100,'식료품'),('0002','상품2','M001',200,'식료품'),('0003','상품3','M002',1980,'생활용품'),('0009','추가상품','M001',300,'식료품');
```

- select * from 상품3;
  
  | 상품코드     | 상품명       | 메이커코드      | 가격   | 상품분류     |
  |--------------|--------------|-----------------|--------|--------------|
  | 0001         | 상품1        | M001            |    100 | 식료품       |
  | 0002         | 상품2        | M001            |    200 | 식료품       |
  | 0003         | 상품3        | M002            |   1980 | 생활용품     |
  | 0009         | 추가상품     | M001            |    300 | 식료품       |
  
- select * from 재고수;
  
  | 상품코드     | 입고날짜     | 재고수    |
  |--------------|--------------|-----------|
  | 0001         | 2014-01-03   |       200 |
  | 0002         | 2014-02-10   |       500 |
  | 0003         | 2014-02-14   |        10 |

- ex) 내부결합에서는 상품코드가 0009인 상품이 제외된다.
  - select 상품3.상품명, 재고수.재고수 from 상품3 inner join 재고수 on 상품3.상품코드=재고수.상품코드 where 상품3.상품분류='식료품';
    
    | 상품명    | 재고수    |
    |-----------|-----------|
    | 상품1     |       200 |
    | 상품2     |       500 |
    
- 이런 경우 외부결합을 사용한다.  
결합하는 테이블 중에 어느 쪽을 기준으로 할지 결정할 수 있다.  
결합의 왼쪽을 기준으로 inner join 대신 left join 을 사용

  - select 상품3.상품명, 재고수.재고수 from 상품3 left join 재고수 on 상품3.상품코드=재고수.상품코드 where 상품3.상품분류='식료품';
    
    | 상품명       | 재고수    |
    |--------------|-----------|
    | 상품1        |       200 |
    | 상품2        |       500 |
    | 추가상품     |      NULL |
  
  - 재고수 테이블에는 0009에 대한 데이터가 없으므로 값이 없으므로 값이 null로 표시 된다.  
기준이 되는 상품 테이블을 join의 왼쪽에 기술했으므로 left join이라 지정.  
상품 테이블을 오른쪽에 지정하는 경우나 재고 테이블을 기준으로 삼고 싶은 경우에는 right join을 사용.  